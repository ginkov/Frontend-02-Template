Week 05 浏览器工作原理

\#学号: G20200447020292
\#姓名: 尹欣
\#班级: 2班
\#小组: 9组
\#作业&总结链接:https://github.com/ginkov/Frontend-02-Template/tree/master/week06



# 1.  CSS 计算 | 收集 CSS 规则 

## 环境准备

​	` npm install css `

+ css@3.0.0

CSS Computing 实际发生在 DOM 树构建的时候。

## 第一步  收集 CSS 规则 

* 遇到 style 标签时，我们把 css 规则保存起来
* 调用了现成的 CSS Parser 来解析
* 要仔细研究 CSS 规则格式，这对后面的代码非常重要。// 随时回来翻看产生的 ast 的结构





# 2. | 添加调用

把 CSS 规则应用上去 

CSS 的潜规则 -- 尽量包证所有的选择器在 startTag 进入的时候就能被判断

总结：

* 当我们创建一个元素后，立即计算 CSS
* 理论上，当我们分析一个元素时，所有 CSS 规则 已经收集完毕
* Head 里的元素，是没有办法计算它的 CSS 的 -- 是不是因为 Head 里要加载 CSS?
* 在真实浏览器中，可能遇到写在 body 的 style 标签，需要重新计算 CSS 的情况，这里我们忽略。



# 3. | 获取父元素序列

**为什么要获取父元素序列？**

因为元素的选择器大多与父元素相关。

总结：

* 在 computeCSS 中，必须 知道元素的所有父元素才能判断是否匹配
* 我们从上一步的 stack，可以得到本元素的所有的父元素
* 因为我们首先获取的是 ”当前元素“，所以我们获得和计算你和元素匹配的顺序是从内向外





# 4. |选择器与元素的匹配

选择器有层级结构

* 最外层的叫选择器列表
* 选择器列表里的叫复杂选择器
  * 复杂选择器是由一系列空格分隔的，我们叫复合选择器

我们只考虑复杂选择器里包含简单选择器的情况，不考虑复合选择器了。

拆分选择器时，只需要对复杂选择器根据空格进行拆分。

总结：

* 选择器和当前元素的父元素一样，都是从内向外匹配
* 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列



# 5. | 计算选择器与元素的匹配

写上一次的 match 函数

总结

* 根据选择器的类型和元素属性，计算是否与当前元素匹配



# 6. | 生成 Computed 属性

总结：

* 一旦选择匹配，就应用选择器到元素，形成 computedStyle



# 7. | specificity 的计算逻辑

要计算 CSS 的优先级，这里指专一性。比如 id 的 专一性高于 class, class 又高于  tagName.

specificity 是一个四元组

[0, 0, 0, 0]

inline, id, class, tagname

* inline - style 属性 - 有的话最高
* id 

以选择器  div div #id 为例

[0, 1, 0, 2]

即： inline -- 为0，因为没有 inline 的 style

id -- 为1

class -- 为 0，因为没有指定 class

tagName -- 为2，因为有两个 tagname

而  div #my #id 生成的四元组为 [0, 2, 0, 1]

写一个函数去计算、再写一个函数去比较 specificity 。

## 总结

* CSS 根据 specificity 和 后来优先规则覆盖
* specificity 是四元组，越左边权重越高
* 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成

现在我们生成了一颗带 CSS 的 DOM 树。接下来该算 Layout 了。

# 8. 排版 Layout| 根据浏览器属性进行排版

现在我们要计算出一颗带位置的 DOM 树，为真实的渲染打好基础。

CSS 有三代排版技术：

* 正常流： position, display, float 等属性，接近于古典的排版技术
* flex:  比较接近正常思维
* grid: 

以 Flex 为例，进行排版。排版有一个主轴的概念。主轴就是我们主要的延伸方向。

和主轴垂直的是交叉轴。

用主轴、交叉轴的定义，屏蔽了 x 为主，或者 y 为主的坐标轴设置。

## 总结

做了非常重要的准备工作。预算归一化了 flexDirection 和 wrap 相关的属性。



# 9. |  收集元素进行（hang 2声）

收集元素进行（hang2）是重要的准备工作。

分行：

* 根据主轴尺寸，把元素分行。如果超出一行，就会新建一行，把元素放在当前行里。
* 若设置了 no-wrap，则强行分配进第一行。

# 10. | 计算主轴

计算主轴方向

* 找出所有 Flex 元素
* 把主轴方向的剩余尺寸按比例分配给这些元素
* 若剩余空间为负数，所有 flex 元素为0，等比压缩剩余元素

比如，我们有3个 flex 元素，分别是 112, 那么它们就分别是 1/4 1/4 和 1/2，按 Flex 值的比例算出来。

对于 no-wrap，所有 flex 元素为0，剩余元素等比例压缩。

# 11. | 计算交叉轴

计算交叉轴

* 根据每一行中最大元素尺寸计算行高
* 根据行高 flex-align 和 item-align 确定元素具体位置即可 

# 12. 渲染 | 绘制单个元素

使用 npm 的 images 库，绘制到图片。

```
npm install images
```

安装 images 3.2.3





# 13. | 绘制 DOM 树

绘制多个元素。递归调用 render 函数。比较简单。

