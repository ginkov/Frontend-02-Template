<style>
    .cell {
        display: inline-block;
        line-height: 7px;
        width: 6px;
        height: 6px;
        background-color: gray;
        border-bottom: solid 1px white;
        border-right: solid 1px white;
        vertical-align: middle;
    }
    #container{
        width:701px;
    }
</style>
<div id="container"></div>
<button onclick="localStorage['amp'] = JSON.stringify(map)">Save</button>

<script>
let map = localStorage['map'] ? JSON.parse(localStorage['map']) : Array(10000).fill(0);

let container = document.getElementById('container');
for(let y=0; y<100; y++) {
    for(let x=0; x<100; x++) {
        let cell = document.createElement('div');
        cell.classList.add('cell');
        if(map[100*y + x ]==1)
            cell.style.backgroundColor = 'black';
        cell.addEventListener('mousemove', ()=> {
            if(mousedown) {
                if(clear) {
                    cell.style.backgroundColor = '';
                    map[100*y +x] = 0;
                }
                else {
                    cell.style.backgroundColor = 'black';
                    map[100*y + x] = 1
                }
            }
        })
        container.appendChild(cell);
    }
}

let mousedown = false;
let clear = false;
document.addEventListener('mousedown', e=> {
    mousedown = true;
    clear = (e.which === 3)
});
document.addEventListener('mouseup', ()=>mousedown=false);
document.addEventListener('contextmenu', e=>e.preventDefault());

function sleep(t) {
    return new Promise(function (resolve) {
        setTimeout (resolve, t);
    })
}

//function path(map, start, end) {
async function path(map, start, end) {
    // 各搜索算法的差异就在于Queue
    // queue 先进先出
    // js 数据的 push / pop; shift / unshift 可以天然模拟栈和队列
    // 如果改成 stack，就是深度优先搜索
    var queue = [start];

    async function insert(x,y) {
        if(x<0 || x>= 100 || y<0 || y>=100) // 如果出界就停
            return;
        if( map[ y * 100 + x ] )  // 如果撞墙，或者也是路，就停
            return;
        await sleep(30);
        container.children[ y * 100 + x].style.backgroundColor = 'lightgreen'; // 直接取 container 的 children 了
        map[y * 100 + x] = 2;  // 标记找过的点  
        queue.push([x,y]);
    }

    while(queue.length) {
        let [x,y] = queue.shift();
        console.log(x,y);
        if(x === end[0] && y === end[1]) {
            return true;
        }
        await insert(x-1, y);  // async 调用时要用 await
        await insert(x, y-1);
        await insert(x+1, y);
        await insert(x, y+1);
    }
    return false

} 
</script>